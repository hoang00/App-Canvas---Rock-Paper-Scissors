# Dependency management: pip-compile vs Poetry

## What I changed âœ…
- Created a backup of your original `requirements.txt` â†’ `requirements.txt.bak`.
- Generated `requirements.in` (unpinned top-level packages) from the current `requirements.txt`.
- Installed `pip-tools` in the repo venv and ran `pip-compile requirements.in` to produce a freshly pinned `requirements.txt`.
- Added this document to explain workflows.

---

## pip-compile (pip-tools) â€” how it works ðŸ”§
- `requirements.in` contains the *top-level* packages your project depends on (no pinned versions).
- `pip-compile requirements.in` resolves those top-level packages and produces a fully pinned `requirements.txt` (including transitive dependencies and exact versions). This makes installs reproducible.
- Common workflow:
  1. Edit `requirements.in` to add/remove top-level deps.
  2. Run `pip-compile requirements.in` to regenerate `requirements.txt`.
  3. Install using `pip install -r requirements.txt` (or use `pip-sync -r requirements.txt` to exactly sync the venv).
- Pros: simple, works with pip, easy to integrate into CI. Good for projects that prefer requirements.txt flows.

## Poetry â€” how it works (short) ðŸ“¦
- Poetry uses `pyproject.toml` to declare dependencies and manages a `poetry.lock` lockfile.
- Workflow:
  - `poetry init` or `poetry add <pkg>` to edit dependencies.
  - `poetry lock` to generate `poetry.lock`.
  - `poetry install` to create a venv and install locked deps.
- Pros: unified tool for dependency management, building and packaging. Can export `requirements.txt` for CI with `poetry export -f requirements.txt --output requirements.txt`.

## Which to choose? ðŸ’¡
- Use **pip-compile** if you prefer plain `pip`/`requirements.txt` workflow and want deterministic pins.
- Use **Poetry** if you want a higher-level tool that manages venvs, publishing, and a structured `pyproject.toml` approach.

## Files added/changed in this repo
- `requirements.txt.bak` (backup)
- `requirements.in` (generated)
- `requirements.txt` (regenerated by `pip-compile`)
- `scripts/generate_requirements_in.py` (helper used to generate `requirements.in`)
- `DEPENDENCY_MANAGEMENT.md` (this file)

---

If you'd like, I can also:
- Convert the project to **Poetry** fully (create `pyproject.toml`, `poetry.lock`, and optionally remove `requirements.in`/`requirements.txt`). I created `pyproject.toml` with runtime deps and the rest as `dev-dependencies` for you.

**Poetry usage & next steps** ðŸ”§
- Install Poetry (recommended):
  - Official installer (recommended, installs CLI):
    - `python -c "import sys; print('See https://install.python-poetry.org for the official installer')"`
  - Or `pip install --user poetry` (installs the poetry package; may not make a `poetry` console command available on Windows).
- To generate the lockfile and install:
  1. `poetry lock` (create `poetry.lock`)
  2. `poetry install` (create virtualenv and install locked dependencies)
- To export requirements for CI:
  - Production (no dev deps): `poetry export -f requirements.txt --output requirements-poetry.txt --without-hashes`
  - With dev deps: `poetry export -f requirements.txt --output requirements-dev.txt --dev --without-hashes`

**Note:** I created `pyproject.toml` but could not produce `poetry.lock` here because the Poetry CLI was not available as an executable in the current venv on Windows; if you'd like, I can either install Poetry's CLI on this machine (installer) and run the lock/export commands, or you can run the two `poetry` commands locally and commit `poetry.lock`. Tell me which you prefer and I'll proceed.

- Run `poetry export` in CI if you need `requirements.txt` style files.

Tell me which option you prefer and I'll proceed.